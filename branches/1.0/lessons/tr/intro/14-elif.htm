<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel='stylesheet' href='../rurple.css' type='text/css'>
<title>If, else, if, else, ....</title>
</head>
<body>
<h2 class="title">14. <span class="pykeyword">if, else, <small>if,
else,</small></span>...</h2>
<p>Bir önceki engelli atlama al&#305;&#351;t&#305;rmas&#305;nda üç seçimlik vermek istedi&#287;imizden 
dolay&#305; (bitir, git veya z&#305;pla) iç içe iki tane <span class="pykeyword">if</span>/<span class=
"pykeyword">else</span> kullanmam&#305;z gerekti. Buda yaz&#305;lan kodun içe içe 
yaz&#305;lmas&#305;n&#305; mecbur hale getirdi. Reeborg'a 10 ayr&#305; seçimlik vermemiz gerekseydi 
ne olurdu; kodlar içe içe yaz&#305;laca&#287;&#305;ndan okunmas&#305; bir hayli zor olacakt&#305;. Bu 
durumu ortadan kald&#305;rmak için&nbsp; Guido van Rossum, Python'un yarat&#305;c&#305;s&#305;,&nbsp;&nbsp; <span class="pykeyword">else</span> 
den sonra kullan&#305;lan&nbsp; <span class="pykeyword">if</span> leri temsil etmek 
için&nbsp; <span class=
"pykeyword">elif </span>ad&#305;nda bir komut haz&#305;rlam&#305;&#351;t&#305;r. <span class=
"pykeyword">elif </span>komutu
<span class="pykeyword">else if</span> in k&#305;salt&#305;lm&#305;&#351;&#305;d&#305;r. Bu yeni komut 
yard&#305;m&#305;yla az önceki kod a&#351;a&#287;&#305;daki gibi yaz&#305;labilir:</p>
<pre>
<span class="keyword">def</span> move_jump_or_finish():
    <span class="keyword">if</span> next_to_beeper():
        turn_off()
    <span class="keyword">elif</span> front_is_clear():
        move()
    <span class="keyword">else</span>:
        jump_one_hurdle()
</pre>
<p>Üç seçimlik oldu&#287;unu &#351;imdi daha rahat görebiliyoruz, seçimlikler ayn&#305; hizada 
yaz&#305;lm&#305;&#351;lar. <span class="pykeyword">else</span> den sonraki komutun 
çal&#305;&#351;t&#305;r&#305;labilmesi için kendisinden önce gelen tüm &#351;artlar&#305;n (<font face="Courier New" size="2">next_to_beeper 
ve front_is_clear</font>) False olmas&#305; gerekir. Daha fazla seçimli&#287;imiz olsayd&#305; 
tek yapmam&#305;z gereken yeni&nbsp; <span class="pykeyword">elif</span> 'ler eklemek 
olacakt&#305;.&nbsp; </p>
<pre>
<span class="keyword">def</span> move_jump_or_finish():
    <span class="keyword">if</span> next_to_beeper():
        turn_off()
    <span class="keyword">elif</span> front_is_clear():
        move()
    <span class="keyword">elif</span> right_is_clear(): <span class=
"comment"># her zaman false</span>
        <span class="keyword">pass</span> 
    <span class="keyword">else</span>:
        jump_one_hurdle()
</pre>
<p>Reeborg en alt duvar&#305;n üstünde hareket etti&#287;inden sa&#287;&#305;nda her zaman bir duvar 
vard&#305;r. Bu nedenle <tt>right_is_clear()</tt> her zaman False sonucunu verir ve <span class="pykeyword">pass</span> 
(Phytonda hiç bir &#351;ey yapma anlam&#305;na gelir) komutu hiç bir zaman yerine 
getirilmez. Bunun yerine<tt> left_is_clear()</tt> kullan&#305;lsayd&#305; True de&#287;erini 
alaca&#287;&#305;ndan Reeborg tak&#305;l&#305;p kalacak ve hiç bir &#351;ey yapmayacakt&#305;.&nbsp; <b>Bunu 
deneyin!</b></p>
<h3 class="try">S&#305;ra sizde</h3>
<p><span class="pykeyword">if, elif, else</span>
kullanarak yeni bir program yaz&#305;n bu program önceki iki al&#305;&#351;t&#305;rmadaki engellerle 
çal&#305;&#351;t&#305;&#287;&#305; gibi a&#351;a&#287;&#305;daki &#351;ekildeki engellerle de çal&#305;&#351;abilsin. (dünya dosyas&#305; 
hurdles3.wld).</p>
<img alt="hurdles start" src="../../images/intro/hurdles3_start.png">
<center><a href="13-else.htm"><img alt="previous" src=
"../../images/previous.png"> Beni dinle yoksa&nbsp; ... or else
....</a> - <a href=
"../lessons_toc.htm"><img alt="home" src="../../images/home.png"></a> - 
<A href="15-not.htm">Do&#287;ru de&#287;il Not true!? <img alt="next" src=
"../../images/next.png"></a></center>
</body>
</html>
